<!-- 876e6dab-ac96-4d43-9153-e5403201e2a4 2ef7e199-5b7e-4d42-b577-5b6bbff4851c -->
# 机器人远程控制系统架构设计

## 1. 系统架构概述

### 1.1 核心设计原则

- **双进程架构**：WebSocket进程 + Worker进程，通过IPC通信
- **单客户端限制**：同一时刻只允许一个客户端连接
- **动态加载**：Python项目动态导入模块，C++项目启动可执行文件
- **异步回调**：Worker执行完成后通过IPC返回结果到WS进程
- **进程级隔离**：Worker崩溃不影响WS Server

### 1.2 进程架构图

```
┌─────────────────────┐         IPC (ZMQ)        ┌──────────────────────┐
│  WebSocket Server   │ ◄──────────────────────► │   Worker Process     │
│  - 接收客户端连接    │   REQ-REP (指令)         │   - Python Executor  │
│  - 单连接管理        │   PUB-SUB (回调)         │   - C++ Executor     │
│  - 指令路由          │                          │   - 项目管理         │
└─────────────────────┘                          └──────────────────────┘
         ▲                                                  │
         │                                                  │
    WebSocket                                         调用机器人SDK
         │                                               (N2等)
         │                                                  │
    ┌────┴────┐                                      ┌─────▼─────┐
    │ Client  │                                      │  Robot    │
    └─────────┘                                      └───────────┘
```

## 2. 项目目录结构

```
robot-control-system/
├── main.py                     # 启动入口（同时启动两个进程）
├── config.yaml                 # 系统配置
├── requirements.txt            # Python依赖
├── ws_server/                  # WebSocket服务进程
│   ├── __init__.py
│   ├── server.py              # WebSocket服务器（FastAPI）
│   ├── connection_manager.py  # 单客户端连接管理
│   └── protocol.py            # 协议定义和验证
├── worker/                     # Worker执行进程
│   ├── __init__.py
│   ├── worker.py              # Worker主进程
│   ├── project_manager.py     # 项目解压和存储
│   ├── python_executor.py     # Python动态执行器
│   └── cpp_executor.py        # C++可执行文件管理器
├── ipc/                        # 进程间通信
│   ├── __init__.py
│   ├── zmq_manager.py         # ZeroMQ封装
│   └── messages.py            # 消息格式定义
├── storage/                    # 运行时目录（.gitignore）
│   ├── projects/              # 解压的项目文件
│   │   └── current/           # 当前加载的项目
│   └── logs/                  # 日志文件
└── tests/                      # 测试代码
    └── ...
```

## 3. 核心模块详细设计

### 3.1 WebSocket Server模块

**文件**: `ws_server/server.py`

**功能**:

- 使用FastAPI + websockets实现WebSocket服务
- 接收客户端连接，验证单连接限制
- 解析客户端指令（update/start/process）
- 通过IPC转发指令到Worker
- 接收Worker回调并推送给客户端

**关键类**:

```python
class WSServer:
    def __init__(self, zmq_manager, connection_manager):
        self.app = FastAPI()
        self.zmq = zmq_manager
        self.conn_mgr = connection_manager
    
    async def websocket_endpoint(self, websocket: WebSocket):
        # 1. 检查是否已有连接
        # 2. 接收消息
        # 3. 路由到对应handler
        # 4. 等待Worker回调并返回
```

**文件**: `ws_server/connection_manager.py`

```python
class ConnectionManager:
    def __init__(self):
        self.active_client = None
        self.lock = asyncio.Lock()
    
    async def connect(self, websocket) -> bool:
        # 如果已有连接，拒绝并返回False
        # 否则记录当前连接
    
    async def disconnect(self):
        # 释放连接
```

**文件**: `ws_server/protocol.py`

定义消息格式：

```python
# 客户端 -> 服务器
UpdateCommand = {
    "command": "update",
    "data": "base64_zip_data"
}

StartCommand = {
    "command": "start"
}

ProcessCommand = {
    "command": "process",
    "params": {
        "object": "sport_client",      # 对象名称
        "method": "StandUp",            # 方法名称
        "args": {}                      # 方法参数
    }
}

# 服务器 -> 客户端
Response = {
    "status": "success|error|callback",
    "message": "...",
    "data": {}
}
```

### 3.2 Worker进程模块

**文件**: `worker/worker.py`

**功能**:

- 启动ZMQ监听，接收WS Server指令
- 管理当前加载的项目状态
- 路由到对应的执行器
- 执行完成后发送回调

**关键类**:

```python
class Worker:
    def __init__(self, zmq_manager):
        self.zmq = zmq_manager
        self.project_mgr = ProjectManager()
        self.python_executor = None
        self.cpp_executor = None
        self.current_project_type = None
    
    def run(self):
        while True:
            msg = self.zmq.receive_command()
            self.handle_command(msg)
    
    def handle_command(self, msg):
        if msg['type'] == 'update':
            self.handle_update(msg)
        elif msg['type'] == 'start':
            self.handle_start(msg)
        elif msg['type'] == 'process':
            self.handle_process(msg)
    
    def handle_update(self, msg):
        # 1. 解压zip
        # 2. 识别项目类型
        # 3. 返回结果
    
    def handle_start(self, msg):
        # 根据项目类型启动
        if self.current_project_type == 'python':
            self.python_executor = PythonExecutor(project_path)
            self.python_executor.load()
        elif self.current_project_type == 'cpp':
            self.cpp_executor = CppExecutor(project_path)
            self.cpp_executor.start()
    
    def handle_process(self, msg):
        # 调用Python函数
        result = self.python_executor.call_function(
            msg['function'], 
            msg['params']
        )
        # 发送回调
        self.zmq.send_callback(result)
```

**文件**: `worker/project_manager.py`

**功能**:

- 解压zip文件
- 识别项目类型（Python/C++）
- 管理项目文件
```python
class ProjectManager:
    def __init__(self, storage_dir='storage/projects'):
        self.storage_dir = storage_dir
    
    def extract_project(self, zip_data: bytes) -> str:
        # 1. 清理旧项目
        # 2. 解压到storage/projects/current/
        # 3. 返回项目路径
    
    def detect_project_type(self, project_path) -> str:
        # 检查是否有.py文件 -> 'python'
        # 检查是否有可执行文件（ELF格式）-> 'cpp'
        # 检查是否有main.cpp等源文件但无可执行文件 -> 'error'
```


**文件**: `worker/python_executor.py`

**功能**:

- 动态导入Python模块
- 解析函数调用路径（如"sport_client.StandUp"）
- 执行函数并捕获异常
```python
import importlib
import sys

class PythonExecutor:
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.module = None
        self.context = {}  # 存储已创建的对象实例
    
    def load(self):
        # 1. 将project_path添加到sys.path
        # 2. 查找main.py或__init__.py
        # 3. 导入主模块
        sys.path.insert(0, self.project_path)
        self.module = importlib.import_module('main')
    
    def call_function(self, func_path: str, params: dict):
        """
        func_path示例: 
        - "sport_client.StandUp"
        - "main.initialize"
        """
        # 1. 解析路径
        parts = func_path.split('.')
        
        # 2. 获取对象或模块
        obj = self.context.get(parts[0]) or getattr(self.module, parts[0])
        
        # 3. 逐层获取属性
        for part in parts[1:-1]:
            obj = getattr(obj, part)
        
        # 4. 调用最终的方法
        method = getattr(obj, parts[-1])
        result = method(**params)
        
        return {
            'status': 'success',
            'result': result
        }
    
    def create_instance(self, class_path: str, args: dict):
        """支持创建对象实例并保存到context"""
        # 例如: create_instance("SportClient", {}) 
        # -> self.context['sport_client'] = SportClient()
```


**文件**: `worker/cpp_executor.py`

**功能**:

- 启动C++可执行文件作为子进程
- 管理子进程生命周期
- （可选）通过stdin/stdout与子进程交互
```python
import subprocess
import os

class CppExecutor:
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.process = None
        self.executable_path = None
    
    def find_executable(self):
        # 遍历项目目录，找到可执行文件
        # 检查文件权限（可执行位）
        for root, dirs, files in os.walk(self.project_path):
            for file in files:
                path = os.path.join(root, file)
                if os.access(path, os.X_OK):
                    return path
        raise FileNotFoundError("No executable found")
    
    def start(self):
        self.executable_path = self.find_executable()
        self.process = subprocess.Popen(
            [self.executable_path],
            cwd=self.project_path,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        return {
            'status': 'success',
            'pid': self.process.pid
        }
    
    def stop(self):
        if self.process:
            self.process.terminate()
            self.process.wait(timeout=5)
```


### 3.3 IPC通信模块

**文件**: `ipc/zmq_manager.py`

**功能**:

- 封装ZeroMQ的REQ-REP和PUB-SUB模式
- 提供简单的send/receive接口
```python
import zmq
import json

class ZMQManager:
    def __init__(self, role='server'):
        self.context = zmq.Context()
        
        if role == 'server':  # WS Server
            self.req_socket = self.context.socket(zmq.REQ)
            self.req_socket.connect("ipc:///tmp/robot-control-cmd.ipc")
            
            self.sub_socket = self.context.socket(zmq.SUB)
            self.sub_socket.connect("ipc:///tmp/robot-control-callback.ipc")
            self.sub_socket.setsockopt_string(zmq.SUBSCRIBE, "")
        
        elif role == 'worker':  # Worker
            self.rep_socket = self.context.socket(zmq.REP)
            self.rep_socket.bind("ipc:///tmp/robot-control-cmd.ipc")
            
            self.pub_socket = self.context.socket(zmq.PUB)
            self.pub_socket.bind("ipc:///tmp/robot-control-callback.ipc")
    
    def send_command(self, msg: dict):
        """WS Server发送指令"""
        self.req_socket.send_json(msg)
        response = self.req_socket.recv_json()
        return response
    
    def receive_command(self):
        """Worker接收指令"""
        msg = self.rep_socket.recv_json()
        return msg
    
    def send_response(self, msg: dict):
        """Worker发送响应"""
        self.rep_socket.send_json(msg)
    
    def send_callback(self, msg: dict):
        """Worker发送异步回调"""
        self.pub_socket.send_json(msg)
    
    def receive_callback(self, timeout=100):
        """WS Server接收回调"""
        if self.sub_socket.poll(timeout):
            return self.sub_socket.recv_json()
        return None
```


## 4. 完整的指令处理流程

### 4.1 UPDATE指令流程

```
Client              WS Server           Worker              FileSystem
  │                    │                   │                    │
  │──update(zip)──────►│                   │                    │
  │                    │──update_cmd──────►│                    │
  │                    │                   │──extract()────────►│
  │                    │                   │◄─path──────────────│
  │                    │                   │──detect_type()────►│
  │                    │◄─response─────────│                    │
  │◄─success───────────│                   │                    │
```

### 4.2 START指令流程（Python项目）

```
Client              WS Server           Worker              Python Module
  │                    │                   │                      │
  │──start────────────►│                   │                      │
  │                    │──start_cmd───────►│                      │
  │                    │                   │──load_module()──────►│
  │                    │                   │◄─module──────────────│
  │                    │◄─response─────────│                      │
  │◄─success───────────│                   │                      │
```

### 4.3 PROCESS指令流程（带回调）

```
Client              WS Server           Worker              Robot SDK
  │                    │                   │                      │
  │──process──────────►│                   │                      │
  │ (StandUp)          │──process_cmd─────►│                      │
  │                    │◄─ack──────────────│                      │
  │◄─ack───────────────│                   │──call_function()────►│
  │                    │                   │                      │ (执行动作)
  │                    │                   │                      │
  │                    │                   │◄─callback────────────│
  │                    │◄─callback(PUB)────│                      │
  │◄─callback──────────│                   │                      │
```

## 5. 配置文件设计

**文件**: `config.yaml`

```yaml
websocket:
  host: "0.0.0.0"
  port: 8000
  max_message_size: 104857600  # 100MB

worker:
  storage_dir: "./storage/projects"
  max_execution_time: 300  # 5分钟
  
ipc:
  command_port: 5555
  callback_port: 5556
  
logging:
  level: "INFO"
  file: "./storage/logs/app.log"
```

## 6. 扩展性和低耦合设计

### 6.1 接口抽象

定义统一的执行器接口：

```python
class BaseExecutor(ABC):
    @abstractmethod
    def load(self):
        pass
    
    @abstractmethod
    def execute(self, command: dict):
        pass
    
    @abstractmethod
    def cleanup(self):
        pass
```

Python和C++执行器都实现这个接口，Worker不需要关心具体实现。

### 6.2 可扩展点

1. **新的项目类型**：实现新的Executor子类
2. **新的IPC方案**：替换ZMQManager实现
3. **新的机器人SDK**：只需在Python项目中使用不同的库
4. **多Worker支持**：改为任务队列 + Worker池（未来扩展）
5. **持久化存储**：添加数据库存储项目元数据

### 6.3 配置驱动

所有端口、路径、超时等配置都从config.yaml读取，便于部署时调整。

## 7. 错误处理和日志

### 7.1 错误类型

- **连接错误**：多客户端尝试连接
- **解压错误**：zip文件损坏
- **类型识别错误**：无法识别项目类型
- **加载错误**：Python模块导入失败
- **执行错误**：函数调用异常
- **超时错误**：执行超时

### 7.2 日志策略

- 每个模块独立的logger
- 记录所有指令和响应
- 记录用户代码的stdout/stderr
- 按天滚动日志文件
```python
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# 文件handler
fh = logging.FileHandler('storage/logs/app.log')
fh.setFormatter(logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
))
logger.addHandler(fh)
```


## 8. 部署方案

### 8.1 依赖安装

**requirements.txt**:

```
fastapi==0.104.1
websockets==12.0
uvicorn==0.24.0
pyzmq==25.1.1
pyyaml==6.0.1
```

### 8.2 启动脚本

**main.py**:

```python
import multiprocessing
from ws_server.server import WSServer
from worker.worker import Worker

def start_ws_server():
    server = WSServer()
    server.run()

def start_worker():
    worker = Worker()
    worker.run()

if __name__ == '__main__':
    ws_process = multiprocessing.Process(target=start_ws_server)
    worker_process = multiprocessing.Process(target=start_worker)
    
    ws_process.start()
    worker_process.start()
    
    try:
        ws_process.join()
        worker_process.join()
    except KeyboardInterrupt:
        ws_process.terminate()
        worker_process.terminate()
```

### 8.3 Docker化（可选）

```dockerfile
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    python3.10 \
    python3-pip

WORKDIR /app
COPY requirements.txt .
RUN pip3 install -r requirements.txt

COPY . .

EXPOSE 8000
CMD ["python3", "main.py"]
```

## 9. 测试策略

### 9.1 单元测试

- 测试ConnectionManager的单连接限制
- 测试ProjectManager的zip解压和类型识别
- 测试PythonExecutor的动态加载
- 测试ZMQManager的消息收发

### 9.2 集成测试

- 模拟客户端发送完整的update -> start -> process流程
- 测试异常情况（如文件损坏、函数不存在等）

## 10. 可行性分析

### 10.1 技术可行性

✅ **高度可行**

- Python的importlib支持动态导入，成熟稳定
- subprocess管理C++可执行文件，标准做法
- ZeroMQ是成熟的IPC方案，性能优秀
- FastAPI的WebSocket支持完善

### 10.2 性能考虑

- **延迟**：IPC通信延迟在ms级别，可接受
- **吞吐量**：单客户端场景无并发压力
- **内存**：动态加载的模块会占用内存，但单项目可控

### 10.3 潜在问题

1. **Python模块卸载困难**：Python无法完全卸载已导入的模块，需要重启Worker进程来切换项目
2. **C++进程管理**：如果C++程序不响应SIGTERM，可能需要SIGKILL强制终止
3. **依赖冲突**：用户上传的Python项目可能依赖不同版本的库

**解决方案**：

- 每次update时重启Worker进程（可接受，因为单客户端）
- C++进程设置终止超时，超时后强制kill
- 使用虚拟环境或容器隔离依赖（进阶方案）

## 11. 总结

该架构具有以下优势：

1. ✅ **低耦合**：WS Server和Worker通过消息通信，可独立开发和测试
2. ✅ **可扩展**：通过接口抽象和配置驱动，易于添加新功能
3. ✅ **稳定性**：进程隔离保证Worker崩溃不影响WS连接
4. ✅ **简洁性**：C++不需要编译，降低复杂度
5. ✅ **实用性**：满足单客户端、动态加载、异步回调等所有需求

可以直接开始实现，建议按以下顺序：

1. 搭建基础项目结构和配置
2. 实现IPC通信模块
3. 实现WebSocket Server和连接管理
4. 实现Worker进程和ProjectManager
5. 实现PythonExecutor
6. 实现CppExecutor
7. 集成测试和调试

### To-dos

- [x] 创建项目目录结构和基础配置文件
- [x] 实现ZeroMQ进程间通信模块
- [x] 实现单客户端连接管理器